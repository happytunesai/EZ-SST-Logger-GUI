# -*- coding: utf-8 -*-
"""
Main entry point for the EZ STT Logger application.
Initializes the necessary components and starts the GUI.
Includes dynamic language scanning and extraction of default resource folders.
"""
import os
import sys
import queue
import threading
import time
import logging
import json    # Needed for loading reference keys
import shutil  # For file copying operations

# --- First, get base path to resolve other modules and paths ---
def get_initial_base_path():
    """Initial path resolution before utils module can be imported"""
    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
        return sys._MEIPASS
    else:
        try:
            return os.path.abspath(os.path.dirname(__file__))
        except:
            return os.path.abspath(os.getcwd())

# --- Local module imports ---
try:
    sys.path.insert(0, get_initial_base_path())  # Ensure our modules are found first
    from lib.logger_setup import logger, setup_logging
    from lib.constants import (
        CONFIG_FILE, KEY_FILE, LOG_DIR, CONFIG_DIR, FILTER_DIR,
        LANGUAGE_DIR, DEFAULT_LANGUAGE, DEFAULT_LOG_LEVEL, LANG_REFERENCE_CODE
    )
    from lib.utils import load_or_generate_key, get_base_path
    from lib.config_manager import load_config
    from lib.gui import WhisperGUI
    from lib.language_manager import (
        set_current_language, load_language, tr,
        scan_languages, discovered_languages
    )
    from lib.appearance_manager import apply_initial_appearance
except ImportError as e:
    print(f"Critical import error in main.py: {e}")
    sys.exit(1)

# --- Global queues and flags ---
audio_q = queue.Queue()
gui_q = queue.Queue()
streamerbot_queue = queue.Queue()
stop_recording_flag = threading.Event()
streamerbot_client_stop_event = threading.Event()

queues = {
    'audio_q': audio_q,
    'gui_q': gui_q,
    'streamerbot_q': streamerbot_queue
}
flags = {
    'stop_recording': stop_recording_flag,
    'stop_streamerbot': streamerbot_client_stop_event
}
handlers = {'console': None, 'file': None}


def extract_bundled_folder(folder_name: str):
    """
    Extracts all files from the bundled <folder_name> in the PyInstaller
    bundle into the external persistent folder next to the EXE, if not present.
    """
    if not getattr(sys, 'frozen', False):
        return
    exe_dir = os.path.dirname(sys.executable)
    dest_dir = os.path.join(exe_dir, folder_name)
    if os.path.isdir(dest_dir):
        return
    os.makedirs(dest_dir, exist_ok=True)
    # Source inside bundle
    if hasattr(sys, '_MEIPASS'):
        src_dir = os.path.join(sys._MEIPASS, folder_name)
    else:
        src_dir = os.path.join(get_base_path(), folder_name)
    if not os.path.isdir(src_dir):
        print(f"Warning: bundled folder '{folder_name}' not found at '{src_dir}'")
        return
    for fname in os.listdir(src_dir):
        src_file = os.path.join(src_dir, fname)
        dst_file = os.path.join(dest_dir, fname)
        if os.path.isfile(src_file):
            try:
                shutil.copy2(src_file, dst_file)
                print(f"Extracted '{folder_name}/{fname}' to '{dest_dir}'")
            except Exception as e:
                print(f"Error extracting '{fname}' in '{folder_name}': {e}")


def prepare_filter_directory():
    """
    Create the filter directory if it doesn't exist.
    Actual filter files will be generated by the application on first run.
    """
    if not getattr(sys, 'frozen', False):
        return
    exe_dir = os.path.dirname(sys.executable)
    external_filter_dir = os.path.join(exe_dir, FILTER_DIR)
    os.makedirs(external_filter_dir, exist_ok=True)


def create_default_config_if_missing():
    """
    Create a default config.json file if it doesn't exist.
    """
    if not getattr(sys, 'frozen', False):
        return
    exe_dir = os.path.dirname(sys.executable)
    config_dir = os.path.join(exe_dir, CONFIG_DIR)
    config_path = os.path.join(config_dir, os.path.basename(CONFIG_FILE))
    os.makedirs(config_dir, exist_ok=True)
    if not os.path.exists(config_path):
        default_config = {
            "mode": "local",
            "openai_api_key": "",
            "elevenlabs_api_key": "",
            "language_ui": DEFAULT_LANGUAGE,
            "log_level": DEFAULT_LOG_LEVEL,
            "local_model": "base",
            "language": "",
            "output_format": "txt",
            "output_filepath": "transcription_log.txt",
            "clear_log_on_start": False
        }
        try:
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(default_config, f, indent=4, ensure_ascii=False)
            print(f"Created default config at: {config_path}")
        except Exception as e:
            print(f"Error creating default config file: {e}")


def main():
    """Initializes the application and starts the main loop."""
    global handlers

    # 1) Extract bundled folders on first start
    for folder in (CONFIG_DIR, FILTER_DIR, LANGUAGE_DIR, 'themes', LOG_DIR):
        extract_bundled_folder(folder)

    # 2) Ensure all resource dirs exist
    base_path = get_base_path() if not getattr(sys, 'frozen', False) else None
    for dir_name in (LOG_DIR, CONFIG_DIR, FILTER_DIR, LANGUAGE_DIR):
        if getattr(sys, 'frozen', False):
            path = os.path.join(os.path.dirname(sys.executable), dir_name)
        else:
            path = os.path.join(base_path, dir_name)
        os.makedirs(path, exist_ok=True)

    # 3) Determine key & config file paths
    if getattr(sys, 'frozen', False):
        exe_dir = os.path.dirname(sys.executable)
        key_file_path = os.path.join(exe_dir, CONFIG_DIR, os.path.basename(KEY_FILE))
        config_file_path = os.path.join(exe_dir, CONFIG_DIR, os.path.basename(CONFIG_FILE))
    else:
        key_file_path = os.path.join(base_path, KEY_FILE)
        config_file_path = os.path.join(base_path, CONFIG_FILE)

    print(f"Using key file: {key_file_path}")
    print(f"Using config file: {config_file_path}")

    # 4) Load or generate encryption key
    encryption_key = load_or_generate_key(key_file_path, gui_q)
    if not encryption_key:
        print("CRITICAL ERROR: Could not load/generate encryption key.")
        sys.exit(1)

    # 5) Load reference language keys
    reference_keys = set()
    try:
        temp = load_language(LANG_REFERENCE_CODE, is_reference_load=True)
        if temp:
            reference_keys = set(temp.keys())
    except Exception as e:
        print(f"ERROR loading reference language: {e}")

    # 6) Scan for available languages
    discovered = scan_languages(reference_keys)
    print(f"Discovered languages: {list(discovered.keys())}")

    # 7) Load app configuration
    app_config = load_config(config_file_path, encryption_key)
    try:
        apply_initial_appearance(app_config)
    except Exception as e:
        print(f"ERROR applying appearance: {e}")

    # 8) Setup logging
    initial_log_level_str = app_config.get("log_level", DEFAULT_LOG_LEVEL)
    _, console_handler, file_handler = setup_logging(initial_console_level_str=initial_log_level_str)
    handlers['console'] = console_handler
    handlers['file'] = file_handler

    # 9) Set UI language
    cfg_lang = app_config.get("language_ui", DEFAULT_LANGUAGE)
    if cfg_lang in discovered:
        set_current_language(cfg_lang)
    else:
        fallback = DEFAULT_LANGUAGE if DEFAULT_LANGUAGE in discovered else (next(iter(discovered), DEFAULT_LANGUAGE))
        set_current_language(fallback)

    # 10) Optionally clear log
    if app_config.get("clear_log_on_start", False) and handlers['file']:
        lf = handlers['file'].baseFilename
        try:
            with open(lf, 'w'): pass
            logger.info(tr("log_logfile_cleared", path=lf))
        except Exception:
            pass

    # 11) Start GUI
    try:
        app = WhisperGUI(app_config, encryption_key, queues, flags, handlers, available_languages=discovered)
        app.mainloop()
    except Exception as e:
        logger.exception(tr("log_gui_exception"))
    finally:
        sys.exit(0)


if __name__ == '__main__':
    main()
