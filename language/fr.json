{
    "language_name": "Français",
    "language_code": "fr",
    "app_title": "EZ STT Logger GUI v.{version}",
    "tab_local": "Local",
    "tab_openai": "API OpenAI",
    "tab_elevenlabs": "API ElevenLabs",
    "tab_websocket": "WebSocket",
    "tab_integration": "Intégration (SB)",
    "label_model_whisper": "Modèle Whisper :",
    "label_api_key_openai": "Clé API OpenAI :",
    "placeholder_api_key_openai": "sk-...",
    "label_api_key_elevenlabs": "Clé API ElevenLabs :",
    "placeholder_api_key_elevenlabs": "Clé ElevenLabs...",
    "label_model_id_elevenlabs": "ID du modèle ElevenLabs :",
    "placeholder_model_id_elevenlabs": "p. ex., scribe_v1",
    "checkbox_filter_parentheses": "Filtrer le contenu entre (...) et [...]",
    "label_websocket_incoming": "Entrant (Contrôle via WebSocket) :",
    "checkbox_websocket_enable": "Activer le serveur WebSocket",
    "label_websocket_port": "Port du serveur :",
    "label_websocket_port_info": "(Par défaut : {port}, Redémarrage de l'application requis en cas de modification)",
    "label_websocket_command_info": "Commande attendue pour activer/désactiver l'enregistrement : TOGGLE_RECORD",
    "label_integration_outgoing": "Sortant (Envoyer à Streamer.bot) :",
    "checkbox_integration_enable": "Envoyer les transcriptions à Streamer.bot",
    "label_integration_url": "URL Streamer.bot :",
    "placeholder_integration_url": "ws://127.0.0.1:8080/",
    "label_integration_url_info": "(Redémarrage de l'application requis en cas de modification)",
    "label_integration_prefix": "Texte de préfixe :",
    "label_mic": "Microphone :",
    "combobox_mic_loading": "Chargement...",
    "combobox_mic_nodata": "Aucun microphone !",
    "combobox_mic_error": "Erreur !",
    "button_mic_reload": "Recharger",
    "label_language_stt": "Langue (vide=Auto) :",
    "placeholder_language_stt": "p. ex., de, en, fr (code ISO)",
    "label_format": "Format :",
    "radio_format_txt": "TXT",
    "radio_format_json": "JSON",
    "label_output_file": "Fichier de sortie :",
    "placeholder_output_file": "Par défaut : {filename}",
    "button_browse": "Parcourir...",
    "label_min_buffer": "Tampon min. (s) :",
    "label_silence_threshold": "Détection du silence (s) :",
    "checkbox_clear_log": "Effacer le fichier journal au démarrage",
    "button_start_recording": "Enregistrer ",
    "button_stop_recording": "Arrêter",
    "button_stopping_recording": "Arrêt en cours...",
    "button_edit_filter": "Modifier les filtres...",
    "button_edit_replacements": "Modifier les remplacements...",
    "button_clear_output": "Effacer l'affichage",
    "status_ready": "Prêt.",
    "status_ready_ws_disabled": "Prêt (Serveur WS désactivé).",
    "status_ready_sb_disabled": " (Envoi à SB désactivé)",
    "status_mic_search": "Recherche de microphones...",
    "status_mic_selected": "Microphone '{mic_name}' sélectionné.",
    "status_mic_invalid": "Sélection de microphone invalide.",
    "status_mics_loaded_selected": "Microphones chargés. Microphone sélectionné.",
    "status_mics_loaded_error": "Microphones chargés, mais erreur de sélection.",
    "status_mics_error": "Erreur lors du chargement des microphones !",
    "status_mics_none": "Aucun microphone trouvé !",
    "status_output_file_selected": "Fichier de sortie : {filename}",
    "status_opening_editor": "Ouverture de '{filename}' dans l'éditeur...",
    "status_opened_editor": "'{filename}' ouvert pour édition.",
    "status_error_opening_file": "Erreur lors de l'ouverture du fichier : {error}",
    "status_error_file_not_found": "Erreur : Fichier '{filename}' introuvable.",
    "status_error_filter_not_found": "Erreur : Le fichier de filtre '{filename}' n'a pas pu être créé/trouvé.",
    "status_error_replacements_not_found": "Erreur : Le fichier de remplacements n'a pas pu être créé/trouvé.",
    "status_output_cleared": "Affichage effacé.",
    "status_error_clearing_output": "Erreur lors de l'effacement de l'affichage.",
    "status_starting_recording": "Démarrage de l'enregistrement...",
    "status_stopping_recording": "Arrêt de l'enregistrement...",
    "status_error_mic_select_fail": "Erreur : Veuillez sélectionner un microphone valide !",
    "status_error_output_dir_create": "Erreur lors de la création du répertoire de sortie : {error}",
    "status_error_output_dir_write": "Erreur : Aucun accès en écriture pour le chemin de sortie.",
    "status_error_api_key_openai": "Erreur : Clé API OpenAI manquante !",
    "status_error_api_key_elevenlabs": "Erreur : Clé API ElevenLabs manquante !",
    "status_error_model_id_elevenlabs": "Erreur : ID du modèle ElevenLabs manquant !",
    "status_error_numeric_buffer": "Erreur : Nombre invalide pour le tampon/silence.",
    "status_error_reading_settings": "Erreur lors de la lecture des paramètres : {error}",
    "status_error_invalid_input": "Entrée invalide : {error}",
    "status_recording_finished": "Enregistrement terminé.",
    "status_worker_unexpected_end": "Travailleur terminé de manière inattendue.",
    "status_error_unexpected_worker": "Erreur inattendue dans le travailleur !",
    "status_error_portaudio": "Erreur de flux audio !",
    "status_error_portaudio_details": "Erreur PortAudio : {error}. Enregistrement arrêté.",
    "status_error_saving_config": "Erreur lors de l'enregistrement de la configuration : {error}",
    "status_error_saving_replacements": "Erreur lors de l'enregistrement du remplacement pour '{text}...'.",
    "status_error_saving_filter": "Erreur lors de l'enregistrement du filtre : {error}",
    "status_error_key_unwritable": "Fichier de clé non accessible en écriture : {error}. Clé API non sécurisée !",
    "status_error_saving_key": "Erreur lors de l'enregistrement de la clé : {e}. Clé API non sécurisée !",
    "status_filter_added": "Ajout de '{text}...' à la liste de filtres ({filename}).",
    "status_replacement_added": "Remplacement pour '{text}...' enregistré.",
    "status_replacement_exists": "Info : Remplacement pour '{text}...' existe déjà.",
    "status_no_selection": "Aucune sélection effectuée.",
    "status_empty_selection": "Sélection vide ignorée.",
    "status_selection_copied": "Sélection copiée.",
    "status_all_copied": "Tout le texte copié.",
    "status_error_copy": "Erreur lors de la copie du texte.",
    "status_ws_server_starting": "Démarrage du serveur WebSocket sur le port {port}...",
    "status_ws_server_running": "Serveur WebSocket en cours d'exécution sur le port {port}",
    "status_ws_server_stopped": "Serveur WebSocket arrêté.",
    "status_sb_client_starting": "Démarrage du client Streamer.bot pour {url}...",
    "status_sb_client_connected": "Connecté à Streamer.bot",
    "status_sb_client_waiting": "En attente de Streamer.bot...",
    "status_sb_client_stopped": "Client Streamer.bot arrêté.",
    "status_sb_warn_disconnected": "Connexion SB fermée.",
    "status_sb_warn_refused": "Connexion WS SB refusée.",
    "status_sb_warn_timeout": "Délai d'attente de la connexion WS SB dépassé.",
    "status_sb_warn_send_error": "Erreur lors de l'envoi à SB : {error}",
    "status_sb_warn_queue_full": "File d'attente SB pleine !",
    "status_error_ws_port_invalid": "Port WS invalide : {port}",
    "status_error_sb_url_invalid": "URL SB invalide : {url}",
    "status_error_ws_lib_missing": "Bibliothèque WebSocket manquante !",
    "status_error_ws_port_busy": "Port WebSocket {port} occupé !",
    "status_error_ws_other": "Erreur de port WebSocket {port} : {error}",
    "status_error_ws_server_task": "Erreur du serveur WebSocket : {error}",
    "status_error_sb_client_task": "Erreur du client WS SB : {error}",
    "status_closing": "Arrêt de l'enregistrement avant la fermeture...",
    "dialog_select_output_file": "Sélectionner le fichier de sortie",
    "dialog_file_type_txt": "Fichier TXT",
    "dialog_file_type_json": "Fichier JSON",
    "dialog_file_type_all": "Tous les fichiers",
    "context_copy": "Copier",
    "context_copy_all": "Tout copier",
    "context_add_filter": "Ajouter à la liste de filtres",
    "context_add_replacement": "Ajouter comme remplacement 'NomDuBot'",
    "context_clear_output": "Effacer l'affichage",
    "label_language_ui": "Langue :",
    "label_log_level": "Niveau de journalisation:",
    "log_level_debug": "Débogage",
    "log_level_info": "Info",
    "log_level_warning": "Avertissement",
    "log_level_error": "Erreur",
    "log_level_critical": "Critique",
    "status_log_level_set": "Niveau de journalisation de la console défini sur : {log_level}",
    "status_error_generic": "Erreur : {error}",
    "log_created_directory": "Répertoire '{path}' créé ou existe déjà.",
    "log_failed_directory": "ERREUR : Impossible de créer le répertoire '{path}' : {error}",
    "log_key_missing": "ERREUR CRITIQUE : Échec du chargement ou de la génération de la clé de chiffrement.",
    "log_logfile_cleared": "Le fichier journal '{path}' a été effacé en raison de la configuration.",
    "log_logfile_clear_error": "Erreur lors de l'effacement du fichier journal '{path}' : {error}",
    "log_logfile_clear_unexpected": "Erreur inattendue lors de l'effacement du fichier journal '{path}'",
    "log_logfile_not_found": "Fichier journal '{path}' introuvable pour l'effacement.",
    "log_logfile_no_handler": "Impossible d'effacer le fichier journal : Aucun gestionnaire de fichier trouvé.",
    "log_app_started": "Démarrage de WhisperGUI...",
    "log_app_ended": "La boucle principale de l'interface graphique s'est terminée.",
    "log_gui_exception": "Erreur critique dans la boucle principale de l'application.",
    "log_app_exiting": "Exécution du script main.py terminée.",
    "log_lang_loading": "Chargement du fichier de langue : {path}",
    "log_lang_loaded": "Langue '{code}' chargée avec succès.",
    "log_lang_default_loaded": "Langue par défaut '{code}' chargée avec succès.",
    "log_lang_not_supported": "Le code de langue '{code}' n'est pas pris en charge. Retour à '{fallback}'.",
    "log_lang_file_missing": "Fichier de langue '{path}' introuvable.",
    "log_lang_default_missing": "Fichier de langue par défaut '{path}' également introuvable ! Les textes de l'interface utilisateur peuvent manquer.",
    "log_lang_parse_error": "Erreur lors du chargement/parsing du fichier de langue '{path}' : {error}",
    "log_lang_key_not_string": "La valeur de la clé '{key}' dans la langue '{code}' n'est pas une chaîne : {text}",
    "log_lang_format_missing": "Espace réservé de formatage '{e}' manquant dans la chaîne pour la clé '{key}' (langue : {code}).",
    "log_lang_format_error": "Erreur de formatage de chaîne pour la clé '{key}' : {error}. Texte original : '{text}'",
    "log_logfile_created": "Fichier journal : {path}",
    "log_console_level_initialized": "Niveau de journalisation de la console initialisé à : {level}",
    "log_file_logging_disabled": "La journalisation dans un fichier est désactivée en raison d'une erreur.",
    "log_logfile_open_error": "ERREUR : Impossible d'ouvrir le fichier journal '{path}' : {error}",
    "log_console_handler_error": "ERREUR : Impossible de créer le gestionnaire de la console : {error}",
    "log_config_loading": "Chargement de la configuration depuis '{path}'...",
    "log_config_file_not_found": "Fichier de configuration introuvable : {path}",
    "log_config_openai_decrypted": "Clé API OpenAI déchiffrée avec succès.",
    "log_config_openai_decrypt_failed": "Impossible de déchiffrer la clé API OpenAI.",
    "log_config_openai_decrypt_error": "Erreur lors du déchiffrement de la clé OpenAI : {error}",
    "log_config_openai_key_found_but_no_decryption": "Clé API OpenAI trouvée dans la configuration, mais aucune clé de déchiffrement fournie.",
    "log_config_elevenlabs_decrypted": "Clé API ElevenLabs déchiffrée avec succès.",
    "log_config_elevenlabs_decrypt_failed": "Impossible de déchiffrer la clé API ElevenLabs.",
    "log_config_elevenlabs_decrypt_error": "Erreur lors du déchiffrement de la clé ElevenLabs : {error}",
    "log_config_elevenlabs_key_found_but_no_decryption": "Clé API ElevenLabs trouvée dans la configuration, mais aucune clé de déchiffrement fournie.",
    "log_config_loaded": "Configuration chargée et traitée avec succès.",
    "log_config_fallback_defaults": "Fichier de configuration '{path}' introuvable. Utilisation des valeurs par défaut.",
    "log_config_parse_error": "Erreur lors de la lecture ou de l'analyse du fichier de configuration '{path}' : {error}. Utilisation des valeurs par défaut.",
    "log_config_unexpected_error": "Erreur inattendue lors du chargement de la configuration. Utilisation des valeurs par défaut.",
    "log_config_invalid_language": "Code de langue invalide '{value}' trouvé dans la configuration. Retour à la valeur par défaut '{fallback}'.",
    "log_config_invalid_log_level": "Niveau de journalisation invalide '{value}' trouvé dans la configuration. Retour à la valeur par défaut '{fallback}'.",
    "log_config_saving": "Enregistrement de la configuration dans '{path}'...",
    "log_config_openai_encrypted": "Clé API OpenAI chiffrée pour l'enregistrement.",
    "log_config_openai_encrypt_failed": "Échec du chiffrement de la clé API OpenAI. NE SERA PAS enregistré.",
    "log_config_openai_no_key": "Clé API OpenAI présente mais aucune clé de chiffrement. NE SERA PAS enregistré.",
    "log_config_elevenlabs_encrypted": "Clé API ElevenLabs chiffrée pour l'enregistrement.",
    "log_config_elevenlabs_encrypt_failed": "Échec du chiffrement de la clé API ElevenLabs. NE SERA PAS enregistré.",
    "log_config_elevenlabs_no_key": "Clé API ElevenLabs présente mais aucune clé de chiffrement. NE SERA PAS enregistré.",
"log_config_invalid_log_level_save": "Tentative d'enregistrement du niveau de journalisation invalide '{value}'. Retour à la valeur par défaut '{fallback}'.",
    "log_config_save_conversion_error": "Erreur lors de la conversion des valeurs numériques lors de l'enregistrement de la configuration : {error}.",
    "log_config_saved": "Configuration enregistrée avec succès.",
    "log_config_save_error": "ERREUR lors de l'enregistrement de la configuration dans '{path}' : {error}",
    "log_config_save_unexpected": "Erreur inattendue lors de l'enregistrement de la configuration",
    "log_utils_crypto_missing": "Bibliothèque de chiffrement (cryptography) non chargée. Opérations de clé impossibles.",
    "log_utils_crypto_missing_short": "Cryptographie manquante !",
    "log_utils_key_loaded": "Clé de chiffrement chargée depuis '{path}'.",
    "log_utils_key_invalid": "Le contenu de '{path}' semble invalide (longueur/format). Génération d'une nouvelle clé.",
    "log_utils_key_read_error": "Erreur lors de la lecture de la clé depuis '{path}' : {error}",
    "log_utils_key_generating": "Génération d'une nouvelle clé de chiffrement...",
    "log_utils_key_saved": "Nouvelle clé enregistrée dans '{path}'.",
    "log_utils_key_important_notice": "!! IMPORTANT : Conservez le fichier '{path}' en sécurité !!\n   Sans lui, la clé API ne peut pas être déchiffrée.\n   NE commettez PAS ce fichier dans Git ou des référentiels publics.",
    "log_utils_key_write_error": "Échec de l'enregistrement de la clé dans '{path}' : {error}",
    "log_utils_key_write_error_short": "Fichier de clé non accessible en écriture : {error}. Sécurité de la clé API compromise !",
    "log_utils_encrypt_failed_crypto": "Échec du chiffrement : Cryptographie non chargée.",
    "log_utils_encrypt_skipped": "Chiffrement ignoré : Aucune clé ou donnée fournie.",
    "log_utils_encrypt_error": "Erreur de chiffrement : {error}",
    "log_utils_decrypt_failed_crypto": "Échec du déchiffrement : Cryptographie non chargée.",
    "log_utils_decrypt_skipped": "Déchiffrement ignoré : Aucune clé ou donnée fournie.",
    "log_utils_decrypt_invalid_token": "Échec du déchiffrement : Jeton invalide (mauvaise clé ou données corrompues ?).",
    "log_utils_decrypt_error": "Erreur de déchiffrement : {error}",
    "log_utils_sounddevice_missing": "Bibliothèque Sounddevice non chargée. Impossible de lister les périphériques audio.",
    "log_utils_searching_devices": "Recherche des périphériques d'entrée audio...",
    "log_utils_audio_query_failed": "ERREUR lors de la requête des périphériques audio",
    "log_utils_audio_query_error": "Erreur lors de l'accès aux périphériques audio : {error}",
    "log_utils_default_device_found": "Périphérique d'entrée par défaut trouvé : Index {index} - {name}",
    "log_utils_no_default_device": "Aucun périphérique d'entrée par défaut explicite signalé.",
    "log_utils_default_device_error": "Impossible de déterminer le périphérique d'entrée par défaut : {error}",
    "log_utils_device_count": "Nombre total de périphériques trouvés : {count}",
    "log_utils_skipping_mme": "Le périphérique {index} ({name}) utilise l'API hôte MME - ignoré.",
    "log_utils_invalid_hostapi_info": "Le périphérique {index} ({name}) n'a pas d'informations d'API hôte valides.",
    "log_utils_hostapi_check_failed": "La vérification de l'API hôte a échoué pour le périphérique {index} : {error}",
    "log_utils_valid_device": "  -> Périphérique d'entrée valide : {name}",
    "log_utils_skipped_device": "  -> Périphérique d'entrée ignoré (API hôte) : ID {index} : {name}",
    "log_utils_valid_input_count": "Nombre de périphériques d'entrée valides trouvés : {count}",
    "log_utils_no_input_devices": "Aucun microphone approprié trouvé.",
    "log_ws_client_connected": "Client WebSocket connecté : {addr}",
    "log_ws_message_received": "Message reçu de {addr} : {msg}",
    "log_ws_command_toggle": "Commande WebSocket : TOGGLE_RECORD détectée – transmission à l'interface graphique.",
    "log_ws_command_unknown": "Commande inconnue '{cmd}' reçue de {addr}.",
    "log_ws_error_unknown_command": "ERREUR : Commande inconnue '{cmd}'.",
    "log_ws_non_text_message": "Message non textuel reçu de {addr}. Seul le texte est pris en charge.",
    "log_ws_error_only_text": "ERREUR : Seuls les messages texte sont pris en charge.",
    "log_ws_client_disconnected_ok": "Le client {addr} a fermé la connexion normalement.",
    "log_ws_client_disconnected_error": "Le client {addr} s'est déconnecté avec une erreur : {error}",
    "log_ws_handler_exception": "Erreur inattendue dans le gestionnaire WebSocket ({addr})",
    "log_ws_connection_closed": "Connexion WebSocket fermée : {addr}",
    "log_ws_lib_missing": "Bibliothèque WebSocket non disponible. Le serveur n'a pas pu démarrer.",
    "log_ws_server_started": "Serveur WebSocket démarré sur {host}:{port}",
    "log_ws_server_stopping": "Arrêt du serveur WebSocket...",
    "log_ws_port_in_use": "Le port WebSocket {port} est déjà utilisé !",
    "log_ws_port_error": "Erreur lors du démarrage du serveur WebSocket sur le port {port} : {error}",
    "log_ws_server_exception": "Erreur inattendue dans le serveur WebSocket.",
    "log_ws_server_closed": "Connexion au serveur WebSocket fermée.",
    "log_ws_server_task_ended": "Tâche du serveur WebSocket terminée.",
    "log_ws_invalid_port": "Port WebSocket invalide : {port}",
    "log_ws_loop_exception": "Exception dans la boucle d'événements du serveur WebSocket.",
    "log_ws_loop_cleanup": "Nettoyage de la boucle d'événements WebSocket...",
    "log_ws_loop_already_shutdown": "Boucle déjà arrêtée, aucune tâche à annuler.",
    "log_ws_loop_runtime_error": "Erreur d'exécution lors de l'annulation de la tâche : {error}",
    "log_ws_loop_cancel_error": "Erreur lors de l'annulation des tâches : {error}",
    "log_ws_loop_closed": "Boucle d'événements WebSocket fermée.",
    "log_ws_loop_already_closed": "La boucle WebSocket était déjà fermée.",
    "log_ws_thread_done": "Thread du serveur WebSocket terminé.",
    "log_ws_thread_starting": "Démarrage du thread du serveur WebSocket sur le port {port}...",
    "log_sb_lib_missing": "Bibliothèque WebSocket non disponible. Le client Streamer.bot ne peut pas démarrer.",
    "log_sb_connecting": "Tentative de connexion à Streamer.bot : {url}",
    "log_sb_connected": "Connecté à Streamer.bot WebSocket : {url}",
    "log_sb_ping_failed": "Échec de la vérification de la connexion Streamer.bot.",
    "log_sb_ping_error": "Erreur lors du ping Streamer.bot : {error}",
    "log_sb_message_sent": "Message envoyé à Streamer.bot : {msg_preview}...",
    "log_sb_send_closed": "Streamer.bot WebSocket fermé lors de l'envoi.",
    "log_sb_send_failed": "Le message n'a pas pu être envoyé : {msg_preview}...",
    "log_sb_send_error": "Erreur lors de l'envoi à Streamer.bot : {error}",
    "log_sb_invalid_url": "URL Streamer.bot WebSocket invalide : {url}",
    "log_sb_connection_closed": "Connexion Streamer.bot WebSocket fermée/réinitialisée : {error}",
    "log_sb_connection_refused": "Connexion Streamer.bot WebSocket refusée : {url}",
    "log_sb_connection_timeout": "Délai d'attente de la tentative de connexion Streamer.bot dépassé (>10s) : {url}",
    "log_sb_unexpected_exception": "Erreur inattendue dans le client Streamer.bot WebSocket",
    "log_sb_connection_closed_explicit": "Connexion Streamer.bot WebSocket fermée explicitement.",
    "log_sb_connection_close_error": "Erreur lors de la fermeture de la connexion Streamer.bot : {error}",
    "log_sb_retry_delay": "Attente de {seconds} secondes avant de réessayer la connexion à Streamer.bot...",
    "log_sb_cancelled": "Attente du client Streamer.bot annulée.",
    "log_sb_task_ended": "Tâche du client Streamer.bot WebSocket terminée.",
    "log_sb_loop_exception": "Erreur lors de l'exécution de la boucle du client Streamer.bot dans le thread",
    "log_sb_loop_cleanup": "Boucle du client Streamer.bot terminée. Nettoyage...",
    "log_sb_loop_already_shutdown": "Boucle Streamer.bot déjà arrêtée.",
    "log_sb_loop_runtime_error": "Erreur d'exécution lors du nettoyage des tâches asyncio dans le thread du client SB : {error}",
    "log_sb_loop_cancel_error": "Erreur lors du nettoyage des tâches asyncio dans le thread du client SB : {error}",
    "log_sb_loop_closed": "Boucle d'événements du client Streamer.bot fermée.",
    "log_sb_loop_already_closed": "La boucle d'événements du client Streamer.bot était déjà fermée.",
    "log_sb_thread_done": "Thread du client Streamer.bot entièrement terminé.",
    "log_sb_thread_starting": "Démarrage du thread du client Streamer.bot pour l'URL : {url}...",
    "log_tp_filter_file_not_found": "Fichier de filtre '{filter_path}' introuvable. Création du fichier avec les modèles par défaut (si disponibles)...",
    "log_tp_filter_default_created": "Fichier de filtre par défaut '{filter_path}' créé.",
    "log_tp_filter_empty_created": "Fichier de filtre vide '{filter_path}' créé (pas de valeurs par défaut pour ce type).",
    "log_tp_filter_create_error": "Impossible de créer le fichier de filtre par défaut '{filter_path}' : {error}",
    "log_tp_filter_invalid_regex": "Regex par défaut invalide '{pattern}' : {error}",
    "log_tp_filter_loading": "Chargement des modèles de filtre depuis '{filter_path}'...",
    "log_tp_filter_invalid_line": "Regex invalide dans '{filter_path}' ligne {line} : '{pattern}' - {error}. Ignoré.",
    "log_tp_filter_loaded": "{count} modèles de filtre chargés depuis '{filename}'.",
    "log_tp_filter_read_error": "Impossible de lire le fichier de filtre '{filter_path}' : {error}. Aucun filtre actif pour ce type.",
    "log_tp_filter_load_unexpected": "Erreur inattendue lors du chargement du fichier de filtre '{filter_path}'",
    "log_tp_filter_applied": "Résultat du filtre : '{result}'",
    "log_tp_replacements_file_not_found": "Fichier de remplacements '{replacements_path}' introuvable. Création d'un exemple de fichier...",
    "log_tp_replacements_created": "Exemple de fichier de remplacements '{replacements_path}' créé.",
    "log_tp_replacements_create_error": "Impossible de créer l'exemple de fichier de remplacements '{replacements_path}' : {error}",
    "log_tp_replacements_loading": "Chargement des remplacements depuis '{replacements_path}'...",
    "log_tp_replacements_invalid_format": "Le contenu de '{replacements_path}' n'est pas un objet JSON valide (dictionnaire attendu).",
    "log_tp_replacements_loaded": "{count} règles de remplacement chargées depuis '{replacements_path}'.",
    "log_tp_replacements_read_error": "Impossible de lire ou d'analyser le fichier de remplacements '{replacements_path}' : {error}. Aucun remplacement actif.",
    "log_tp_replacements_load_unexpected": "Erreur inattendue lors du chargement des remplacements depuis '{replacements_path}'",
    "log_tp_replacements_saving": "Enregistrement des remplacements dans '{replacements_path}'...",
    "log_tp_replacements_save_error": "Impossible d'écrire dans le fichier de remplacements '{replacements_path}' : {error}",
    "log_tp_replacements_save_unexpected": "Erreur inattendue lors de l'enregistrement des remplacements",
    "log_tp_replacements_applied": "Remplacements appliqués. Résultat : '{result}'",
    "log_tp_replacements_rule_error": "Erreur lors de l'application du remplacement regex '{pattern}' -> '{replacement}' : {error}",
    "log_tp_replacements_unexpected_error": "Erreur inattendue lors du remplacement '{pattern}' -> '{replacement}' : {error}",
    "log_tp_replacements_saved": "{count} règles de remplacement enregistrées dans '{replacements_path}'.",
    "log_tp_replacements_merge_error": "Le fichier existant '{replacements_path}' contient un dictionnaire invalide. Il sera écrasé.",
    "log_ap_audio_callback_status": "Statut du rappel audio : {status}",
    "log_ap_libs_missing": "Bibliothèque Sounddevice ou Soundfile non disponible. Enregistrement impossible.",
    "log_ap_whisper_missing": "Erreur : Bibliothèque Whisper manquante.",
    "log_ap_whisper_local_unavailable": "Le mode local n'est pas disponible. Installez 'openai-whisper'.",
    "log_ap_openai_missing": "Erreur : Bibliothèque OpenAI manquante.",
    "log_ap_openai_unavailable": "Le mode OpenAI n'est pas disponible. Installez 'openai'.",
    "log_ap_openai_key_missing": "Erreur : Aucune clé API OpenAI.",
    "log_ap_openai_key_invalid": "Aucune clé API OpenAI fournie ou chargée.",
    "log_ap_elevenlabs_missing": "Erreur : Bibliothèque ElevenLabs manquante.",
    "log_ap_elevenlabs_unavailable": "Bibliothèque ElevenLabs non installée (pip install elevenlabs).",
    "log_ap_elevenlabs_key_missing": "Erreur : Aucune clé API ElevenLabs.",
    "log_ap_elevenlabs_key_invalid": "Aucune clé API ElevenLabs fournie ou chargée.",
    "log_ap_loading_model": "Chargement du modèle Whisper local '{model_name}'... (Cela peut prendre du temps)",
    "log_ap_model_loaded": "Modèle local '{model_name}' chargé.",
    "log_ap_model_load_error": "Erreur lors du chargement du modèle Whisper local {model_name}",
    "log_ap_model_load_error_details": "Erreur lors du chargement du modèle : {error}\\nVérifiez l'existence/la mémoire/FFmpeg !",
    "log_ap_model_already_loaded": "Le modèle local '{model_name}' est déjà chargé.",
    "log_ap_using_loaded_model": "Utilisation du modèle local '{model_name}' déjà chargé.",
    "log_ap_initializing_openai": "Initialisation du client API OpenAI...",
    "log_ap_openai_ready": "Client API OpenAI prêt.",
    "log_ap_openai_initialized": "Client API OpenAI initialisé avec succès.",
    "log_ap_openai_auth_error": "Erreur d'authentification OpenAI. Clé API invalide ?",
    "log_ap_openai_key_invalid_status": "Erreur : Clé API OpenAI invalide !",
    "log_ap_openai_key_expired": "La clé API OpenAI est invalide ou a expiré.",
    "log_ap_openai_init_error": "Erreur lors de l'initialisation du client API OpenAI",
    "log_ap_openai_init_error_status": "Erreur d'initialisation de l'API OpenAI !",
    "log_ap_openai_init_error_details": "Erreur d'initialisation OpenAI : {error}\\nVérifiez la clé/Internet.",
    "log_ap_initializing_elevenlabs": "Initialisation du client API ElevenLabs...",
    "log_ap_elevenlabs_ready": "Client API ElevenLabs prêt.",
    "log_ap_elevenlabs_initialized": "Client API ElevenLabs initialisé avec succès.",
    "log_ap_elevenlabs_api_error": "Erreur API ElevenLabs lors de l'initialisation : {error}",
    "log_ap_elevenlabs_api_error_status": "Erreur : Erreur API ElevenLabs ({code}) !",
    "log_ap_elevenlabs_error_details": "Erreur API ElevenLabs : {error}\\nVérifiez la clé/l'état du compte.",
    "log_ap_elevenlabs_init_error": "Erreur lors de l'initialisation du client API ElevenLabs",
    "log_ap_elevenlabs_init_error_status": "Erreur d'initialisation de l'API ElevenLabs !",
    "log_ap_elevenlabs_init_error_details": "Erreur d'initialisation ElevenLabs : {error}\\nVérifiez la clé/Internet.",
    "log_ap_unknown_mode": "Mode de traitement inconnu demandé : {mode}",
    "log_ap_unknown_mode_status": "Erreur : Mode inconnu '{mode}'",
    "log_ap_local_transcription_start": "Démarrage de la transcription locale (Longueur : {length}s, Options : {options})",
    "log_ap_local_transcription_result": "Résultat de la transcription locale : '{text}'",
    "log_ap_openai_transcription_start": "Envoi à l'API OpenAI (Modèle : {model}, Langue : {language}, Invite : {has_prompt}, Longueur : {length}s)",
    "log_ap_openai_transcription_result": "Réponse de l'API OpenAI : '{text}'",
    "log_ap_elevenlabs_transcription_start": "Envoi à l'API ElevenLabs (Modèle : {model}, Longueur : {length}s)",
    "log_ap_elevenlabs_unexpected_response": "Structure de réponse inattendue de ElevenLabs STT : {response}",
    "log_ap_elevenlabs_transcription_result": "Réponse de l'API ElevenLabs : '{text}'",
    "log_ap_openai_api_error": "Erreur API OpenAI : {error}",
    "log_ap_openai_api_error_status": "Erreur API OpenAI Seg !",
    "log_ap_openai_auth_error_during_transcription": "Erreur d'authentification OpenAI pendant la transcription.",
    "log_ap_openai_auth_error_status": "Erreur Auth OpenAI Seg !",
    "log_ap_elevenlabs_api_error_transcription": "Erreur API ElevenLabs : {error}",
    "log_ap_portaudio_error": "Erreur PortAudio pendant la transcription",
    "log_ap_audio_error_status": "Erreur Audio Seg !",
    "log_ap_runtime_error": "Erreur d'exécution pendant la transcription : {error}",
    "log_ap_runtime_error_status": "Erreur d'exécution Seg ! ({error})",
    "log_ap_transcription_error": "Erreur de transcription générique en mode {mode}",
    "log_ap_transcription_error_status": "Erreur de transcription {api_name} Seg !",
    "log_ap_worker_start": "Démarrage du travailleur d'enregistrement. Mode : {mode}, Périphérique : {device}, Modèle : {model}",
    "log_ap_client_init_failed": "Échec de l'initialisation du client STT. Arrêt du travailleur.",
    "log_ap_using_openai_prompt": "Utilisation de l'invite API OpenAI : '{prompt}'",
    "log_ap_open_audio_stream": "Ouverture du flux audio depuis le périphérique {device_id}...",
    "log_ap_audio_stream_configured": "Flux audio configuré : Fréquence = {rate}, Canaux = {channels}, TailleBloc = {blocksize}",
    "log_ap_audio_stream_started": "Flux audio démarré. Attente des données audio...",
    "log_ap_recording_running": "Enregistrement en cours ({mode}) - Parlez maintenant.",
    "log_ap_speech_detected": "Parole détectée.",
    "log_ap_silence_detected": "Silence détecté ({seconds}s).",
    "log_ap_processing_segment": "Traitement du segment {segment_id} ({mode})...",
    "log_ap_segment_length": "Traitement du segment {segment_id} (Longueur : {length}s)",
    "log_ap_segment_finished": "Segment {segment_id} terminé ({mode}). Attente de la prochaine parole.",
    "log_ap_segment_result": "Résultat du segment {segment_id} (filtré) : '{text}'",
    "log_ap_processing_remainder": "Traitement du reste {segment_id} après le silence ({mode})...",
    "log_ap_processing_remainder_length": "Traitement du reste {segment_id} (Longueur : {length}s)",
    "log_ap_remainder_finished": "Segment {segment_id} (reste) terminé ({mode}). Attente de la prochaine parole.",
    "log_ap_remainder_result": "Résultat du segment {segment_id} (reste) : '{text}'",
    "log_ap_file_write_error": "Erreur lors de l'écriture dans le fichier de sortie '{filename}' : {error}",
    "log_ap_file_write_error_remainder": "Erreur d'écriture (reste) '{filename}' : {error}",
    "log_ap_file_unexpected_error": "Erreur inattendue lors de l'écriture du fichier '{filename}'",
    "log_ap_file_unexpected_error_remainder": "Erreur de fichier inattendue (reste) '{filename}'",
    "log_ap_sb_message_sent": "Message envoyé à la file d'attente Streamer.bot : {message}",
    "log_ap_sb_message_sent_remainder": "Message (reste) à la file d'attente SB : {message}",
    "log_ap_sb_queue_full": "La file d'attente Streamer.bot est pleine. Message rejeté.",
    "log_ap_sb_queue_full_remainder": "La file d'attente Streamer.bot (reste) est pleine.",
    "log_ap_sb_queue_error": "Erreur lors de l'ajout à la file d'attente Streamer.bot : {error}",
    "log_ap_sb_queue_error_remainder": "Erreur lors de l'ajout à la file d'attente SB (reste) : {error}",
    "log_ap_portaudio_stream_error": "Erreur PortAudio dans le flux audio",
    "log_ap_worker_unexpected_error": "Erreur inattendue dans le thread du travailleur d'enregistrement",
    "log_ap_worker_ending": "Arrêt du travailleur d'enregistrement.",
    "log_ap_stream_stopped": "Flux audio arrêté et fermé.",
    "log_ap_stream_close_error": "Erreur lors de la fermeture du flux audio : {error}",
    "log_ap_audio_queue_cleared": "File d'attente audio effacée.",
    "log_ap_worker_thread_ended": "Thread du travailleur d'enregistrement entièrement terminé. Statut : {status}",
    "log_gui_tab_mapping_created": "Carte initiale Nom d'onglet à Mode créée : {mapping}",
    "log_gui_setup_window": "Configuration de la fenêtre principale...",
    "log_gui_icon_not_found": "Fichier d'icône '{icon_file}' introuvable.",
    "log_gui_icon_error": "Erreur lors de la définition de l'icône : {error}",
    "log_gui_window_setup_complete": "Configuration de la fenêtre principale terminée.",
    "log_gui_creating_widgets": "Création des widgets...",
    "log_gui_widgets_created": "Widgets créés.",
    "log_gui_initial_tab_set": "Onglet initial défini sur : {tab_name}",
    "log_gui_initial_tab_error": "Impossible de définir l'onglet initial '{tab_name}' : {error}. Retour en arrière.",
    "log_gui_fallback_tab_error": "Échec de la définition de l'onglet de secours : {error}",
    "log_gui_loading_initial_data": "Chargement des données initiales de l'interface graphique...",
    "log_gui_initial_data_loaded": "Données initiales de l'interface graphique chargées.",
    "log_gui_no_output_path": "Aucun chemin de sortie trouvé dans la configuration, utilisation de la valeur par défaut : {default_path}",
    "log_gui_starting_background_tasks": "Démarrage des tâches en arrière-plan...",
    "log_gui_language_change_requested": "Changement de langue demandé : {language}",
    "log_gui_language_changing": "Changement de langue en cours : {code} ({name})",
    "log_gui_language_code_not_found": "Impossible de trouver le code de langue pour '{language}'.",
    "log_gui_language_not_found": "La langue enregistrée '{language}' est introuvable dans SUPPORTED_LANGUAGES. Retour à la valeur par défaut.",
    "log_gui_log_level_change_requested": "Changement de niveau de journalisation demandé : {level}",
    "log_gui_log_level_set": "Niveau de journalisation de la console défini sur {level_str} ({level_name}).",
    "log_gui_log_level_set_error": "Erreur lors de la définition du niveau de journalisation pour la console : {error}",
    "log_gui_console_handler_missing": "Gestionnaire de la console introuvable, impossible de définir le niveau de journalisation.",
    "log_gui_invalid_log_level": "Chaîne de niveau de journalisation invalide trouvée : {level}",
    "log_gui_log_level_str_not_found": "Impossible de trouver la chaîne de niveau de journalisation pour '{level}'.",
    "log_gui_log_level_not_found": "Niveau de journalisation enregistré '{level}' -> '{display}' introuvable dans les options. Retour en arrière.",
    "log_gui_websocket_checkbox_changed": "Case à cocher du serveur WebSocket modifiée : {state}",
    "log_gui_streamerbot_checkbox_changed": "Case à cocher du client Streamer.bot modifiée : {state}",
    "log_gui_updating_ui_texts": "Mise à jour des textes de l'interface utilisateur...",
    "log_gui_tab_names_update_warning": "Les noms des onglets ne peuvent pas être mis à jour directement après l'initialisation.",
    "log_gui_ui_texts_updated": "Textes de l'interface utilisateur mis à jour.",
    "log_gui_output_file_selected": "Fichier de sortie sélectionné : {filepath}",
    "log_gui_opening_file": "Tentative d'ouverture du fichier '{filepath}' dans l'éditeur par défaut...",
    "log_gui_file_not_found": "Fichier introuvable lors de la tentative d'ouverture : {filepath}",
    "log_gui_os_error_opening_file": "Erreur du système d'exploitation lors de l'ouverture de '{filepath}' : {error}",
    "log_gui_unknown_error_opening_file": "Erreur inconnue lors de l'ouverture de '{filepath}'",
    "log_gui_textbox_clear_error": "Erreur lors de l'effacement de la zone de texte",
    "log_gui_copy_selection_error": "Erreur lors de la copie de la sélection : {error}",
    "log_gui_copy_all_error": "Erreur lors de la copie de tout le texte : {error}",
    "log_gui_filter_added_context": "Filtre ajouté via le menu contextuel : '{text}' à {target_file}",
    "log_gui_filter_write_error": "Erreur lors de l'écriture dans le fichier de filtre '{target_file}' : {error}",
    "log_gui_filter_add_error": "Erreur lors de l'ajout à la liste de filtres via le menu contextuel",
    "log_gui_replacement_added_context": "Nouveau remplacement ajouté via le menu contextuel : '{pattern}' -> '{replacement}'",
    "log_gui_mic_thread_error": "Erreur dans le thread de chargement du microphone",
    "log_gui_tkerror_check_button": "TclError dans _check_record_button_state (Arrêt ?).",
    "log_gui_check_button_error": "Erreur inattendue dans _check_record_button_state : {error}",
    "log_gui_toggle_recording_called": "Appel de toggle_recording. Statut actuel : {status}",
    "log_gui_recording_active": "Enregistrement actif",
    "log_gui_recording_inactive": "Non enregistrement",
    "log_gui_stopping_recording": "Arrêt de l'enregistrement...",
    "log_gui_stop_requested": "Arrêt demandé.",
    "log_gui_starting_recording": "Démarrage de l'enregistrement...",
    "log_gui_validating_start_conditions": "Validation des conditions de démarrage...",
    "log_gui_start_conditions_failed": "Conditions de démarrage non remplies.",
    "log_gui_gathering_runtime_config": "Collecte de la configuration d'exécution...",
    "log_gui_config_gathering_failed": "Échec de la collecte de la configuration.",
    "log_gui_preparing_worker_args": "Préparation des arguments du travailleur...",
    "log_gui_worker_args_error": "Erreur avec les arguments du travailleur : {error}",
    "log_gui_clearing_stop_flag": "Effacement de l'indicateur d'arrêt et mise à jour de l'interface graphique...",
    "log_gui_starting_worker_thread": "Démarrage du thread recording_worker (Mode : {mode})...",
    "log_gui_worker_thread_started": "Thread recording_worker démarré.",
    "log_gui_output_dir_created": "Répertoire de sortie créé (Valider) : {output_dir}",
    "log_gui_error_mic_id_not_found": "ID du microphone introuvable.",
    "log_gui_worker_preparation": "Préparation du travailleur : output_file = '{output_file}'",
    "log_gui_runtime_config_error": "Erreur lors de la collecte de la configuration d'exécution : {error}",
    "log_gui_external_toggle_command": "Commande de basculement externe pour l'enregistrement reçue (via la file d'attente de l'interface graphique).",
    "log_gui_calling_toggle_recording": "Appel de self.toggle_recording() depuis _process_gui_queue...",
    "log_gui_toggle_recording_call_finished": "Appel à self.toggle_recording() depuis _process_gui_queue terminé.",
    "log_gui_worker_finished": "Travailleur d'enregistrement a signalé 'terminé'.",
    "log_gui_unknown_message_type": "Type de message inconnu dans la file d'attente de l'interface graphique : {type}",
    "log_gui_queue_processing_error": "Erreur dans la boucle de traitement de la file d'attente de l'interface graphique",
    "log_gui_status_label_update_error": "Impossible de mettre à jour l'étiquette d'état (fenêtre fermée ?).",
    "log_gui_status": "Statut de l'interface graphique : {message}",
    "log_gui_sending_ws_stop_signal": "Envoi du signal d'arrêt au serveur WebSocket...",
    "log_gui_ws_stop_event_set_via_loop": "Événement d'arrêt pour le serveur WebSocket défini via call_soon_threadsafe.",
    "log_gui_ws_loop_not_found": "Impossible de trouver la boucle pour l'événement d'arrêt WebSocket ou elle n'est plus en cours d'exécution. Tentative de définition directe.",
    "log_gui_ws_stop_event_error": "Erreur lors de la définition de l'événement d'arrêt WebSocket : {error}",
    "log_gui_sending_sb_stop_signal": "Envoi du signal d'arrêt au client Streamer.bot...",
    "log_gui_tab_mode_not_found": "Impossible de trouver le mode interne pour le nom d'onglet '{tab_name}' dans la carte fixe. Retour à 'local'.",
    "log_gui_closing_initiated": "Processus de fermeture lancé...",
    "log_gui_setting_stop_flag": "Définition de l'indicateur stop_recording_flag...",
    "log_gui_waiting_for_recording_thread": "Attente de la fin du thread d'enregistrement (max 2s)...",
    "log_gui_recording_thread_timeout": "Le thread d'enregistrement ne s'est pas terminé après 2s.",
    "log_gui_recording_thread_terminated": "Thread d'enregistrement terminé avec succès.",
    "log_gui_no_active_recording_thread": "Aucun thread d'enregistrement actif trouvé à terminer.",
    "log_gui_stopping_background_threads": "Arrêt des threads d'arrière-plan...",
    "log_gui_saving_final_config": "Enregistrement de la configuration finale...",
    "log_gui_final_config_saved": "Configuration finale enregistrée.",
    "log_gui_final_config_save_error": "Erreur lors de l'enregistrement de la configuration finale.",
    "log_gui_final_config_gather_error": "Impossible de collecter/enregistrer la configuration finale.",
    "log_gui_waiting_before_destroy": "Attente brève...",
    "log_gui_destroying_window": "Destruction de la fenêtre Tkinter.",
    "log_gui_application_terminated": "Application terminée.",
    "log_gui_save_config_pre_rebuild": "Sauvegarde config. avant màj UI (langue).",
    "log_gui_config_dir_ensured": "Dossier config. assuré : {config_dir}",
    "log_gui_create_config_dir_failed": "Erreur création dossier config. {config_dir} : {error}",
    "log_gui_config_saved_pre_rebuild": "Config. sauvegardée avant màj langue.",
    "log_gui_config_save_error_pre_rebuild": "Erreur sauvegarde avant màj langue.",
    "log_gui_gather_config_failed_pre_rebuild": "Erreur collecte avant màj langue.",
    "status_error_config_dir_create": "Erreur création dossier config.",
    "log_gui_current_tab_pre_change": "Onglet actuel avant changement langue : '{name}', mode : '{mode}'",
    "log_gui_get_tab_failed_pre_change": "Impossible d'obtenir l'onglet actuel avant changement langue : {error}",
    "log_gui_tab_restored": "Onglet actif restauré : '{name}' (mode : '{mode}')",
    "log_gui_restore_tab_failed": "Impossible de restaurer l'onglet actif '{mode}' : {error}. Retour au premier onglet.",
    "log_gui_mem_config_updated": "self.config en mémoire mis à jour avec les valeurs UI actuelles.",
    "log_gui_current_tab_pre_change": "Onglet actuel avant changement langue : '{name}', mode : '{mode}'",
    "log_gui_get_tab_failed_pre_change": "Impossible d'obtenir l'onglet actuel avant changement langue : {error}",
    "log_gui_tab_restored": "Onglet actif restauré : '{name}' (mode : '{mode}')",
    "log_gui_restore_tab_failed": "Impossible de restaurer onglet actif '{mode}' : {error}. Retour au premier onglet.",
    "log_gui_mem_config_updated": "Configuration mémoire (self.config) mise à jour avec valeurs UI actuelles.",
    "log_info_pyinstaller_path": "Exécution via bundle PyInstaller, chemin base : {path}",
    "log_info_source_path": "Exécution depuis source, chemin base depuis info.py : {path}",
    "log_info_main_script_path": "Exécution depuis source (script principal), chemin base : {path}",
    "log_info_source_path_fallback": "Exécution depuis source (chemin fallback info.py), chemin base : {path}, Erreur accès main : {error}",
    "log_info_link_opened": "Lien ouvert : {url}",
    "log_info_link_open_error": "Impossible d'ouvrir le lien {url} : {error}",
    "log_info_label_update_error": "Erreur MàJ étiquette statut release depuis thread : {error}",
    "log_info_release_check_start": "Vérification nouvelle release sur {url}",
    "log_info_release_versions": "Dernière version release : {latest}, Version actuelle : {current}",
    "log_info_packaging_missing": "Librairie Python 'packaging' non trouvée, comparaison simple de chaînes utilisée pour versions.",
    "log_info_version_parse_error": "Impossible de comparer versions avec 'packaging' : {error}. Comparaison de chaînes utilisée.",
    "log_info_release_newer": "Nouvelle release trouvée : {latest}",
    "log_info_release_latest": "L'application est à jour. Version : {current}",
    "log_info_release_timeout": "Timeout vérification release GitHub sur {url}",
    "log_info_release_request_error": "Erreur vérification release GitHub (RequestException) : {error}",
    "log_info_release_unexpected_error": "Erreur inattendue vérification release GitHub : {error}",
    "tab_info": "Infos",
    "label_repo_link": "Dépôt Projet",
    "label_addon_link": "Addon PNGTuber",
    "button_check_release": "Vérifier MàJ",
    "status_checking_release": "Vérification mises à jour...",
    "status_latest_release": "Vous utilisez la dernière version ({current_version}).",
    "status_new_release_available": "Mise à jour disponible : Version {latest_version} !",
    "status_release_check_error": "Erreur vérification MàJ : {error}",
    "error_timeout": "Timeout",
    "error_unknown": "Erreur inconnue",
    "error_opening_link": "Impossible d'ouvrir le lien : {url}\nErreur : {error}",
    "log_gui_info_tab_created": "Contenu onglet Infos créé via info.create_info_tab.",
    "log_gui_info_tab_create_error": "Échec création contenu onglet Infos : {error}",
    "button_download_update": "Télécharger MàJ",
    "status_enabled": "Activé",
    "status_disabled": "Désactivé"
  }